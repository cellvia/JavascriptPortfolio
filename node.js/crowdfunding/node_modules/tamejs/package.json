{
  "author": {
    "name": "Max Krohn",
    "email": "max@okcupid.com"
  },
  "name": "tamejs",
  "description": "JavaScript-to-JavaScript code rewriter for taming async-callback-style code",
  "version": "0.4.9",
  "keywords": [
    "tame",
    "libasync",
    "okws",
    "sfslite"
  ],
  "preferGlobal": true,
  "repository": {
    "type": "git",
    "url": "git://github.com/maxtaco/tamejs.git"
  },
  "bugs": {
    "email": "max@okcupid.com",
    "url": "http://github.com/maxtaco/tamejs/issues"
  },
  "main": "lib/tamejs.js",
  "bin": {
    "tamejs": "lib/main.js"
  },
  "engines": "node >= 0.4",
  "scripts": {
    "test": "node test/harness.js"
  },
  "directories": {
    "lib": "lib",
    "bin": "./bin"
  },
  "homepage": "http://github.com/maxtaco/tamejs",
  "readme": "tamejs\n======\nThis package is a source-to-source translator that outputs JavaScript. The\ninput dialect looks a lot like JavaScript, but introduces the `await` \nprimitive, which allows asynchronous callback style code to work more\nlike straight-line threaded code.  *tamejs* is written in JavaScript.\n\nOne of the core powers of the *tamejs* rewriting idea is that it's\nfully compatible with existing vanilla-JS code (like `node.js`'s\nlibraries).  That is, existing `node.js` can call code that's been\noutput by the *tamejs* rewriter, and conversely, code output by the\n*tamejs* rewriter can call existing `node.js` code.  Thus, *tamejs* is\nincrementally deployable --- you can keep all of your old code and\njust write the new bits in *tamejs*!  So try it out and let us\nknow what you think.\n\nNEWS\n--------\n\nNow available in\n[NEWS.md](https://github.com/maxtaco/tamejs/blob/master/NEWS.md).\nVersion v0.4 just released, with initial support for what everyone has\nbeen asking for --- Tame-aware stack traces! See the section\n\"Debugging and Stack Traces...\" below for more details.   Also,\nwe've added `autocb`s, that fire whenever your tamed function returns.\n\n\nCode Examples\n--------\nHere is a simple example that prints \"hello\" 10 times, with 100ms delay\nslots in between:\n\n```javascript  \nfor (var i = 0; i < 10; i++) {\n    await { setTimeout (defer (), 100); }\n    console.log (\"hello\");\n}\n```\n\nThere is one new language addition here, the `await { ... }` block,\nand also one new primitive function, `defer`.  The two of them work\nin concert.  A function must \"wait\" at the close of a `await` block\nuntil all `defer`rals made in that `await` block are fulfilled.  The\nfunction `defer` returns a callback, and a callee in an `await`\nblock can fulfill a deferral by simply calling the callback it was\ngiven.  In the code above, there is only one deferral produced in each\niteration of the loop, so after it's fulfilled by `setTimer` in 100ms,\ncontrol continues past the `await` block, onto the log line, and back\nto the next iteration of the loop.  The code looks and feels like\nthreaded code, but is still in the asynchronous idiom (if you look at\nthe rewritten code output by the *tamejs* compiler).\n\nThis next example does the same, while showcasing power of the\n`await{..}` language addition.  In the example below, the two timers\nare fired in parallel, and only when both have fulfilled their deferrals\n(after 100ms), does progress continue...\n\n```javascript\nfor (var i = 0; i < 10; i++) {\n    await { \n        setTimeout (defer (), 100); \n        setTimeout (defer (), 10); \n    }\n    console.log (\"hello\");\n}\n```\n\nNow for something more useful. Here is a parallel DNS resolver that\nwill exit as soon as the last of your resolutions completes:\n\n```javascript\nvar dns = require(\"dns\");\n\nfunction do_one (cb, host) {\n    var err, ip;\n    await { dns.resolve (host, \"A\", defer (err, ip));}\n    if (err) { console.log (\"ERROR! \" + err); } \n    else { console.log (host + \" -> \" + ip); }\n    cb();\n}\n\nfunction do_all (lst) {\n    await {\n        for (var i = 0; i < lst.length; i++) {\n            do_one (defer (), lst[i]);\n        }\n    }\n}\n\ndo_all (process.argv.slice (2));\n```\n\nYou can run this on the command line like so:\n\n    node src/13out.js yahoo.com google.com nytimes.com okcupid.com tinyurl.com\n\nAnd you will get a response:\n\n    yahoo.com -> 72.30.2.43,98.137.149.56,209.191.122.70,67.195.160.76,69.147.125.65\n    google.com -> 74.125.93.105,74.125.93.99,74.125.93.104,74.125.93.147,74.125.93.106,74.125.93.103\n    nytimes.com -> 199.239.136.200\n    okcupid.com -> 66.59.66.6\n    tinyurl.com -> 195.66.135.140,195.66.135.139\n\nIf you want to run these DNS resolutions in serial (rather than\nparallel), then the change from above is trivial: just switch the\norder of the `await` and `for` statements above:\n\n```javascript  \nfunction do_all (lst) {\n    for (var i = 0; i < lst.length; i++) {\n        await {\n            do_one (defer (), lst[i]);\n        }\n    }\n}\n```\n\nSlightly More Advanced Example\n-----------------------------\n\nWe've shown parallel and serial work flows, what about something in\nbetween?  For instance, we might want to make progress in parallel on\nour DNS lookups, but not smash the server all at once. A compromise is\nwindowing, which can be achieved in *tamejs* conveniently in a number\nof different ways.  The [2007 academic paper on\ntame](http://pdos.csail.mit.edu/~max/docs/tame.pdf) suggests a\ntechnique called a *rendezvous*.  A rendezvous is implemented in\n*tamejs* as a pure JS construct (no rewriting involved), which allows\na program to continue as soon as the first deferral is fulfilled (rather than\nthe last):\n\n```javascript  \nfunction do_all (lst, windowsz) {\n    var rv = new tame.Rendezvous ();\n    var nsent = 0;\n    var nrecv = 0;\n\n    while (nrecv < lst.length) {\n        if (nsent - nrecv < windowsz && nsent < n) {\n            do_one (rv.id (nsent).defer (), lst[nsent]);\n            nsent++;\n        } else {\n            var evid;\n            await { rv.wait (defer (evid)); }\n            console.log (\"got back lookup nsent=\" + evid);\n            nrecv++;\n        }\n    }\n}\n```\n\nThis code maintains two counters: the number of requests sent, and the\nnumber received.  It keeps looping until the last lookup is received.\nInside the loop, if there is room in the window and there are more to\nsend, then send; otherwise, wait and harvest.  `Rendezvous.defer`\nmakes a deferral much like the `defer` primitive, but it can be\nlabeled with an idenfitier.  This way, the waiter can know which\ndeferral has fulfileld.  In this case we use the variable `nsent` as the\ndefer ID --- it's the ID of this deferral in launch order.  When we\nharvest the deferral, `rv.wait` fires its callback with the ID of the\ndeferral that's harvested.  \n\nNote that with windowing, the arrival order might not be the same as\nthe issue order. In this example, a slower DNS lookup might arrive\nafter faster ones, even if issued before them.\n\nComposing Serial And Parallel Patterns\n--------------------------------------\n\nIn Tame, arbitrary composition of serial and parallel control flows is\npossible with just normal functional decomposition.  Therefore, we\ndon't allow direct `await` nesting.  With inline anonymous JavaScript\nfunctions, you can consicely achieve interesting patterns.  The code\nbelow launches 10 parallel computations, each of which must complete\ntwo serial actions before finishing:\n\n```javascript\nfunction f(cb) {\n    await {\n        for (var i = 0; i < n; i++) {\n            (function (cb) {\n                await { setTimeout (defer (), 5*Math.random ()); }\n                await { setTimeout (defer (), 4*Math.random ()); }\n                cb();\n             })(defer ());\n        }\n    }\n    cb();\n}\n```\n\n\nautocb\n-------------------\n\nMost of the times, a tamed function will call its callback and return\nat the same time.  To get this behavior \"for free\", you can simply\nname this callback `autocb` and it will fire whenver your tamed function\nreturns.  For instance, the above example could be equivalently written as:\n\n```javascript\nfunction f(autocb) {\n    await {\n        for (var i = 0; i < n; i++) {\n            (function (autocb) {\n                await { setTimeout (defer (), 5*Math.random ()); }\n                await { setTimeout (defer (), 4*Math.random ()); }\n             })(defer ());\n        }\n    }\n}\n```\nIn the first example, recall, you call `cb()` explicitly.  In this\nexample, because the callback is named `autocb`, it's fired\nautomatically when the tamed function returns.\n\nIf your callback needs to fulfill with a value, then you can pass\nthat value via `return`.  Consider the following function, that waits\nfor a random number of seconds between 0 and 4. After waiting, it\nthen fulfills its callback `cb` with the amount of time it waited:\n\n```javascript\nfunction rand_wait(cb) {\n    var time = Math.floor (Math.random()*5);\n    if (time == 0) {\n         cb(0); return;\n    }\n    await setTimeout (defer (), time);\n    cb(time); // return here, implicitly.....\n}\n```\n\nThis function can written equivalently with `autocb` as:\n\n```javascript\nfunction rand_wait(autocb) {\n    var time = Math.floor (Math.random()*5);\n    if (time == 0) {\n        return 0;\n    }\n    await setTimeout (defer (), time);\n    return time;\n}\n```\nImplicitly, `return 0;` is mapped by the tamejs compiler to `autocb(0); return`.\n \n\nInstalling and Using\n--------------------\n\nInstall via npm:\n\n    npm install -g tamejs\n\nYou can their either use the *tamejs* compiler on the command line:\n\n    tamejs -o <outfile> <infile>\n    node <outfile> # or whatever you want\n\nOr as an extension to node's module import system:\n\n```javascript\nrequire ('tamejs').register (); // register the *.tjs suffix\nrequire (\"mylib.tjs\");          // then use node.js's import as normal\n```\n\nIf you want a different extension, this will work:\n\n```javascript\nrequire ('tamejs').register ('tamejs'); // register the *.tamejs suffix\nrequire (\"mylib.tamejs\");               // then use node.js's import as normal\n```\n\nOr, finally, you can call `register` to do a few things at once,\nincluding multiple suffix registrations:\n\n```javascript\n// Will register suffixes 'tamejs' and 'yojs'; will\n// also enable tame stack tracing, and disable caching of\n// .tjs files included at runtime\nrequire ('tamejs').register ({ extension       : [ 'tamejs', 'yojs'], \n                               catchExceptions : true,\n\t\t\t       disableCache    : true })\nrequire (\"mylib.tamejs\");\nrequire (\"yourlib.yojs\");\n```\n\n\nAPI and Documentation\n---------------------\n\n### defer\n\n`defer` can be called in one of two ways.\n\n\n#### Inline Variable Declaration\n\nThe first allows for inline declaration of the callback slot\nvariables:\n\n```javascript\n\nawait { dns.resolve (\"okcupid.com\", defer (var err, ip)); }\n\n```\n\nIn the tamed output code, the variables `err` and `ip` will be\ndeclared right before the start of the `await` block that contains them.\n\n\n#### Generic LHS Assignment w/ \"Rest\" Parameters\n\nThe second approach does not auto-declare the callback slot variables, but\nallows more flexibility:\n\n```javascript\nvar d = {};\nvar err = [];\nawait { dns.resolve (\"okcupid.com\", defer (err[0], d.ip)); }\n```\nThis second version allows anything you'd normally put on the\nleft-hand side of an assignment.\n\nFor callbcacks with variadic return, `tamejs` also supports the [rest\nparameter](http://wiki.ecmascript.org/doku.php?id=harmony:rest_parameters)\nproposal. The above code could have been written as:\n\n```javascript\nvar d = {};\nvar err = [];\nvar rest;\nawait { dns.resolve (\"okcupid.com\", defer (...rest)); }\nerr[0] = rest[0];\nd.ip = rest[1];\n```\n\nAnd of course, it's allowable to mix and match:\n\n```javascript\nvar d = {};\nvar err = [];\nvar rest;\nawait { dns.resolve (\"okcupid.com\", defer (err[0], ...rest)); }\nd.ip = rest[0];\n```\n\n### tame.Rendezvous\n\nThe `Rendezvous` is a not a core *tamejs* feature, meaning it's written as a \nstraight-ahead JavaScript library.  It's quite useful for more advanced\ncontrol flows, so we've included it in the main runtime library.\n\nThe `Rendezvous` is similar to a blocking condition variable (or a\n\"Hoare sytle monitor\") in threaded programming.\n\n#### tame.Rendezvous.id (i).defer (slots,...)\n\nAssociate a new deferral with the given Rendezvous, whose deferral ID is\n`i`, and whose callbacks slots are supplied as `slots`.  Those slots\ncan take the two forms of `defer` return as above (i.e.,\ndeclarative, or generic).  As with standard `defer`, the\nreturn value of the `Rendezvous`'s `defer` is fed to a function\nexpecting a callback.  As soon as that callback fires (and the deferral\nis fulfilled), the provided slots will be filled with the arguments to\nthat callback.\n\n#### tame.Rendezvous.defer (slots,...)\n\nYou don't need to explicitly assign an ID to a deferral generated from a\nRendezvous.  If you don't, one will automatically be assigned, in\nascending order starting from `0`.\n\n#### tame.Rendezvous.wait (cb)\n\nWait until the next deferral on this rendezvous is fulfilled.  When it\nis, callback `cb` with the ID of the fulfilled deferral.  If an\nunclaimed deferral fulfilled before `wait` was called, then `cb` is fired\nimmediately.\n\nThough `wait` would work with any hand-rolled JS function expecting\na callback, it's meant to work particularly well with *tamejs*'s\n`await` function.\n\n#### Example\n\nHere is an example that shows off the different inputs and \noutputs of a `Rendezvous`.  It does two parallel DNS lookups,\nand reports only when the first returns:\n\n```javascript\nvar hosts = [ \"okcupid.com\", \"google.com\" ];\nvar ips = [ ], errs = [];\nvar rv = new tame.Rendezvous ();\nfor (var i in hosts) {\n    dns.resolve (hosts[i], rv.id (i).defer (errs[i], ips[i]));\n}\nawait rv.wait (defer (var which));\nconsole.log (hosts[which] + \" -> \" + ips[which]);\n```\n\n### connectors\n\nA *connector* is a *tamejs* function that takes as input\na callback, and outputs another callback.   The best example \nis a `timeout`, given here:\n\n#### connectors.timeout(cb, time, res = [])\n\nTimeout an arbitrary async operation.\n\nGiven a callback `cb`, a time to wait `time`, and an array to output a\nresult `res`, return another callback.  This connector will set up a\nrace between the callback returned to the caller, and the timer that\nfires after `time` milliseconds.  If the callback returned to the\ncaller fires first, then fill `res[0] = true;`.  If the timer won\n(i.e., if there was a timeout), then fill `res[0] = false;`.\n\nIn the following example, we timeout a DNS lookup after 100ms:\n\n```javascript\nrequire ('tamejs').register (); // since connectors is a tamed library...\nvar timeout = require ('tamejs/lib/connectors').timeout;\nvar info = [];\nvar host = \"pirateWarezSite.ru\";\nawait dns.lookup (host, timeout (defer (var err, ip), 100, info));\nif (!info[0]) {\n    console.log (host + \": timed out!\");\n} else if (err) {\n    console.log (host + \": error: \" + err);\n} else {\n    console.log (host + \" -> \" + ip);\n}\n```\n\n### The Pipeliner library\n\nThere's another way to do the windowed DNS lookups we saw earlier ---\nyou can use the control flow library called `Pipeliner`, which \nmanages the common pattern of having \"m calls total, with only\nn of them in flight at once, where m > n.\"\n\nThe Pipeliner class is available in the connectors library:\n\n```javascript\nrequire ('tamejs').register (); // since connectors is a tamed library...\nvar Pipeliner = require ('tamejs/lib/connectors').Pipeliner;\nvar pipeliner = new Pipeliner (w,s);\n```\n\nUsing the pipeliner, we can rewrite our earlier windowed DNS lookups\nas follows:\n\n```javascript  \nfunction do_all (lst, windowsz) {\n    var pipeliner = new Pipeliner (windowsz);\n\n    for (var i in lst) {\n        await pipeliner.waitInQueue (defer ());\n        do_one (pipeliner.defer (), lst[i]);\n    }\n    await pipeliner.flush (defer ());\n}\n```\n\nThe API is as follows:\n\n### new Pipeliner (w, s)\n\nCreate a new Pipeliner controller, with a window of at most `w` calls\nout at once, and waiting `s` seconds before launching each call.  The\ndefault values are `w = 10` and `s = 0`.\n\n### Pipeliner.waitInQueue (c)\n\nWait in a queue until there's room in the window to launch a new call.\nThe callback `c` will be fulfilled when there is room.\n\n### Pipeliner.defer (...args)\n\nCreate a new `defer`al for this pipeline, and pass it to whatever\nfunction is doing the actual work.  When the work completes, fulfill\nthis `defer`al --- that will update the accounting in the pipeliner\nclass, allowing queued actions to proceed.\n\n### Pipeliner.flush (c)\n\nWait for the pipeline to clear out.  Fulfills the callback `c`\nwhen the last action in the pipeline is done.\n\n\nDebugging and Stack Traces -- Now Greatly Improved!\n---------------------------------------------------\n\nAn oft-cited problem with async-style programming, with Tame or\nhand-rolled, is that stack traces are often incomplete or\nincomprehensible.  If an exception is caught in a tamed function, the\nstack trace will only show the \"bottom half\" of the call stack, or all\nof those functions that are descendents of the main event loop.  The\n\"top half\" of the call stack, telling you \"who _really_ called this\nfunction,\" is probably long gone.\n\nTame has a workaround to this problem.  When a tamed function is\nentered, the runtime will find the first argument to the function that\nwas output by `defer()`.  Such callbacks are annotated to contain the\nfile, line and function where they were created.  They also are\nannotated to hold a refernce to `defer()`-generated callback passed to\nthe function in which they were created.  This chaining creates an\nimplicit stack that can be walked when an exception is thrown.\n\nConsider this example:\n\n```javascript\ntame.catchExceptions ();\n\nfunction foo (y) {\n    await setTimeout (defer (), 10);\n    throw new Error (\"oh no!\")\n    y(10);\n}\n\nfunction bar (x) {\n    await foo (defer ());\n    x();\n}\n\nfunction baz () {\n   await bar (defer ());\n};\n\nbaz ();\n```\n\nThe function `tame.catchExceptions` sets the `uncaughtException`\nhandler in Node to print out the standard callstack, and also the Tame\n\"callstack\", and then to exit.  The callback generated by `defer()`\nin the function `bar` holds a reference to `x`.  Similarly, \nthe callback generated in `foo` holds a reference to `y`.\nHere's what happens when this program is run:\n\n```\nError: oh no!\n    at /home/max/node/tamejs/8.js:31:23\n    at callChain (/home/max/node/tamejs/lib/runtime.js:38:2)\n    at Deferrals._continuation (/home/max/node/tamejs/lib/runtime.js:38:23)\n    at Deferrals._fulfill (/home/max/node/tamejs/lib/runtime.js:149:11)\n    at Object._onTimeout (/home/max/node/tamejs/lib/runtime.js:64:4)\n    at Timer.callback (timers.js:83:39)\nTame 'stack' trace:\n    at bar (8.tjs:10)\n    at baz (8.tjs:15)\n```\n\nThe first stack trace is the standard Node stacktrace.  It is\ninscrutable, since it mainly covers Tame internals, and has line\nnumbering relative to the translated file (I still haven't fixed this\nbug, sorry). The second stack trace is much better.  It tells the\nsequence of tamed calls the lead to this exception.  Line numbers are\nrelative to the original input file.\n\nIn future releases, we'll be cleaning this feature up, but for now, it's a\nmarked improvement over previous versions of tamejs.\n\nThe relavant API is as follows:\n\n#### tame.stackWalk (cb)\n\nStart from the given `cb`, or use the currently active callback\nif none was given, and walk up the Tame-generated stack. Return\na list of call site descriptions.  You can call this from your\nown exception-handling code.\n\n#### tame.catchExceptions()\n\nTell the Tame runtime to catch uncaught exceptions, and to print\na Tame-aware stack dump as above.\n\n\nHow It's Implemented In JavaScript\n----------------------------------\n\nThe key idea behind the *tamejs* implementation is\n[Continuation-Passing Style\n(CPS)](http://en.wikipedia.org/wiki/Continuation-passing_style)\ncompilation.  That is, elements of code like `for`, `while` and `if`\nstatements are converted to anonymous JavaScript functions written\nin continuation-passing style.  Then, `await` blocks just grab\nthose continuations, store them away, and call them when the\ntime is right (i.e., when all relevant deferrals have been fulfilled).\n\nFor example, the simple program:\n\n```javascript\nif (true) { await { setTimeout (defer (), 100); } }\n```\n\nIs rewritten to something like the following (which has been hand-simplified\nfor demonstration purposes):\n\n```javscript\nvar tame = require('tamejs').runtime;\nvar f0 = function (k) {\n    var f1 = function (k) {\n        var __cb = new tame.Deferrals (k);\n        setTimeout ( __cb.defer(), 100 ) ;\n    };\n    if (true) {\n        f1 (k);\n    } else {\n        k();\n    }\n};\nf0 (tame.end);\n\n```\n\nThat is, the function `f0` is the rewrite of the `if` statement.\nFunction `f0` takes as a parameter the continuation `k`, which\nsignifies \"the rest of the program\".  In the case of this trivial\nprogram, the rest of the program is just a call to the exit function\n`tame.end`.  Inside the `if` statement, there are two branches.  In\nthe `true` branch, we call into `f1`, the rewrite of the `await`\nblock, and in the `false` branch, it's just go on with the rest of the\nprogram by calling the continuation `k`.  Function `f1` is doing\nsomething a little bit different --- it's passing its continuation\ninto the pure JavaScript class `tame.Deferrals`, which will hold onto it\nuntil all associated deferrals (like the one passed to `setTimeout`) have\nbeen fulfilled.  When the last deferral is fulfileld (here after 100ms), then\nthe `tame.Deferrals` class calls the continuation `k`, which here refers\nto `tame.end`.\n\nThe *tamejs* implementation uses other CPS-conversions for `while` and\n`for` loops, turning standard iteration into tail-recursion.  If you\nare curious to learn more, examine the output of the *tamejs* compiler\nto see what your favorite JavaScript control flow is translated to.\nThe translation of `switch` is probably the trickiest.\n\nAs you might guess, the output code is less efficient than the input\ncode.  All of the anonymous functions add bloat.  This unfortunate\nside-effect of our approach is mitigated by skipping CPS compilation\nwhen possible.  Functions with no `await` blocks are passed through\nunmolested.  Similarly, blocks within tamed functions that don't call\n`await` can also pass through.\n\nAnother concern is that the use of tail recursion in translated loops\nmight overflow the runtime callstack.  That is certainly true for\nprograms like the following:\n\n```javascript\nwhile (true) { await { i++; } }\n```\n\n...but you should never write programs like these!  That is, there's no\nreason to have a `await` block unless your program needs to wait for\nsome asynchronous event, like a timer fired, a packet arrival, or a \nuser action.  Programs like these:\n\n```javascript\nwhile (true) { await { setTimeout (defer (), 1); i++; } }\n```\n\nwill **not** overflow the runtime stack, since the stack is unwound every\niteration through the loop (via `setTimeout`). And these are the types\nof programs that you should be using `await` for.\n\nToDos\n------\nSee the github issue tracker for the more immediate issues.\n\n* Optimizations\n     * Can passThrough blocks in a tamed function that don't have awaits,\nso can get more aggressive here --- in progress, but can still\nseek out some more optimizations....\n* Parsing\n     * Switch to uglify's parser?  Would have to slightly modify it.\n\nHistory\n-------\n\nThe Tame rewriting idea come about at\n[OkCupid](http://www.okcupid.com) in 2006. Until that time, the\nwebsite was written in an entirely asynchronous-callback-based style\nwith [OKWS](http://www.okws.org) in C++.  This serving technology was\nextremely fast, and led to huge cost savings in hardware and hosting,\nbut as the site's code grew, it became increasingly\nunmanageable. Simple serial loops with network access, like the\nsequential DNS example above, required \"stack-ripping\" into multiple\nmutually recursive calls.  As more employees began to work the code,\nand editted code that they didn't write, development slowed to a\ncrawl.\n\nChris Coyne, OkCupid's director of product, demanded that something be\ndone.  The requirements were manifold.  The new solution had to be\ncompatible with existing code; it had to be incrementally deployable,\nso that the whole codebase wouldn't need to be rewritten at once; it\nhad to be nearly as fast as the status quo; it had to clean the code\nup, so that it was readable; it had to speed up and simplify\ndevelopment.\n\nThe answer that emerged was Tame for C++.  It's a source-to-source\ntranslator that mapped C++ with a few language additions into regular\nC++, which is then compiled with a standard compiler (like `gcc`). The\nkey implementation ideas behind Tame C++ are: (1) generate a heap-allocated\n\"closure\" for each tamed function; (2) use labels and `goto` to jump\nback into tamed function as asynchronous events fired.  Once Tame was\nbrought to bear on OkCupid's code, it offered almost all of the\nflexibilty and performance of hand-crafted\nasynchronous-callback-passing code without any of the stack-ripping\nheadaches.  New employees picked it right up, and contributed to\nthe incremental effort to modernize OkCupid's code to the Tame\ndialect.\n\nOkCupid to this day runs Tame and OKWS in C++ to churn out\nhigh-performance, parallel applications, without worrying about\ntraditional thread-based headaches, like deadlock and race-conditions.\nOur goal with *tamejs* is to bring these benefits to JavaScript and\nthe `node.js` platform.\n\nSee our \"Glossy Page\"\n---------------------\n\nSee [tamejs.org](http://tamejs.org) for documentation and information on \n*tamejs*.\n\nRelated Projects & Plugs\n------------------------\n\n[pubjs](https://github.com/maxtaco/pubjs) is yet another a node.js\ntemplating engine.  But it allows arbtirarily nested code and output\nsections.  Check it out, if you like this sample code:\n\n```html\n<table>\n{% \n  foreach (match in matches) {\n    if (match.score > 60) {{<div>Excellent Match (%{match.score})</div>}}\n    else                  {{<div>Crap Match  (%{match.score})</div>}}\n    foreach (friend in match.friends) {{\n      <p>\n        Has a friend named %{friend.name}\n        {%\n          if (friend.gender == \"f\") {{ and she's a girl }}\n        %}\n      </p>\n    }}\n  }\n%}\n</table>\n```\n\n\nAlso Available In C++!\n----------------------\n\nAs described above, the Tame source-to-source translator was\noriginally written for asynchronous C++ code.  It's an actively\nmaintained project, and it is in widespread use at\n[OkCupid.com](http://www.okcupid.com).  See the [sfslite/tame\nWiki](http://okws.org/doku.php?id=sfslite:tame2) for more information,\nor read the [2007 Usenix ATC\npaper](http://pdos.csail.mit.edu/~max/docs/tame.pdf).\n\nAuthors\n-------\n* Max Krohn (first name AT okcupid DOT com)\n* Chris Coyne (first name AT okcupid DOT com)\n* Eddie Kohler (original Tame coauthor, and advisor)\n\nLicense\n-------\nCopyright (c) 2011 Max Krohn for HumorRainbow, Inc., under the MIT license\n",
  "_id": "tamejs@0.4.9",
  "dist": {
    "shasum": "1fb93ad18ce18a6e849fdea4f3cf6b844a5dfa1f"
  },
  "_from": "tamejs"
}
